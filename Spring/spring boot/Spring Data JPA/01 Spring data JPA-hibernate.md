## Setup
1. dependency
2. application.properties with data source and dialect
# hibernate requires a no args constructor to work properly with entities

JDBC still requires alot of boiler plate like with row mapper and  and passing all the parameters into the query and making prepared statements

Spring data JPA is just specification (interface) hibernate is the implementation
![[Pasted image 20241026110606.png]]
## important interfaces
### Repository - 
its an empty interface
it takes two generic parameters 1. the model and 2. the primary key column type
### CrudRepository
has basic methods for CRUD operations, and method to save, the save method is supposed to insert if new primary key and update if primary key already exists
### ListCrudRepository
Has List instead of an iterable wherever possible like in findall findallbyid and saveall
### PagingAndSortingRepository or ListPagingAndSortingRepository
provides methods to perform pagination and sorting when retrieving
has only two methods `Iterable<T> findAll(Sort sort);` and `Page<T> findAll(Pageable pageable);`
### JPARepository
Interface implements all these interfaces
just like MongoRepository
# Spring data JPA 
this project implements all these interfaces using hibernate

1. to be able to use the repository of a model we need to define that model as an @Entity, and annotations like @Table and @Column,
## to make JPA ignore a property when reading from database
use `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)` over the field
##### JPA will try to match by removing the underscore as well
use table if pojo and table name are not same, same for column
### Id with custom column and table name
```java

@Entity
@Table(name="contact_msg")
public class Contact extends BaseEntity{
	@Id
	@GeneratedValue(strategy = GenerationType.Identity)
	@Column(name = "contact_id")
	private Long contactId;
}
```
### how to make base entity columns part of model as well, use the annotation @MappedSuperClass
```java
@Data
@MappedSuperclass
public class BaseEntity{
	private LocalDataTime createdAt;
	private LocalDataTime updatedAt;
	private String createdBy;
	private String updatedBy;
}
```
### Create an interface for the Model by extending one of the Repository interfaces
```java
@Repository
public interface CotactRepository extends JpaRepository<Contact,Long>{

}
```

### enable JPA by telling the springboot application where to find the interface and where to find the models
```java
@SpringBootApplication
@EnableJpaRepositories("com.sharmachait.wazir.repository")
@EntityScan("com.sharmachait.wazir.models")
public class Wazir {
 
}
```
not required if the entities and repositories are in a sub package of the main class with @SpringBootApplication

### to convert enum to String
```java
@Data
@Entity
@Table(name="holidays")
public class Holiday extends BaseEntity{
	@Id
	private String day;
	private String reason;
	@Enumerated(EnumType.STRING)
	private Type type;
	
	public enum Type{
		FESTIVAL, FEDERAL
	}
}
```

after this we can inject the ContactRepository any where we want

```java
@Service
public class ContactService {
	@Autowired
	private ContactRepository contactrepository;
	public boolean saveMessageDetails(Contact contact){
		boolean isSave = false;
		Contact savedContact = contactRepository.save(contact);
		if(saveContact != null && savedContact.getContactId() > 0){
			isSaved = true;
		}
		return isSaved;
	}
	
}
```

#### updating an entry in the data base requires us to fetch it first make changes and save again
the find methods return an Optional instead of the object
```java
public boolean updateMsg(int contactId, String updatedBy){
	boolean isUpdated  =false;
	Optional<Contact> contact = contactRepository.findById(contactId);
	contact.ifPresent(
		c -> {
			c.setStatus(ContactStatus.close);
			c.setUpdatedBy(updatedBy);
			c.updatedAt(LocalDateTime.now());
		}
	);
	Contact updatedContact = contactRepository.save(contact.get());
	if(updatedContact!=null && updatedContact.getUpdatedBy()!=null){
		isUpdated=true;
	}
	return isUpdated;
}
```

#### how to fetch data with custom logic? based on some random fields that are not ids, we need to use ==**Derived query methods**==
we just need to define query methods in our interface, and JPA will automatically create implementations that fetches data from the database based on those parameters
```java
List<Person> findByLastName(String lastName);
Person findByEmail(String email);
Person findByEmailAndLastName(String email, String lastName);
```

```java
@Repository
public interface CotactRepository extends CrudRepository<Contact,Integer>{
	List<Contact> findByStatus(String status);
	List<Contact> findByStatusAndDate(String status, String Date);
}
```

8. to see the sql that was generated by the framework in the console your application.properties should look like this
```
spring.datasource.url=""
spring.datasource.username=admin
apring.datasource.password=somepassword
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```
# sorting
two kinds of sorting supported by the spring data jpa
1. static 
```java
List<Person> findByOrderByName();
List<Person> findByOrderByNameDesc();
```
2. dynamic
choosing dynamically at runtime what the data should be sorted on when fetching from the database
send the Sort object as well
```java
Sort sort = Sort.by("name").descending().and(Sort.by("age").ascending());
List<Courses> = coursesRepository.findAll(sort);
```

JPA will sort the data based on the sort object for us for the built in methods only that are being implemented by the spring data jpa 
but for any custom methods in the repository methods we need to define them so that they expect a sort object
```java
public interface CoursesRepository extends JpaRepository<Courses, Long> {
    List<Courses> findBySomeCriteria(String criteria, Sort sort);
    List<Courses> findBySomeCriteria();
	
	@Async
	Future<Courses> findByName(String name);
}
```
the string criteria is a must have and it will not work without it
the criteria will be used to filter and sort used to sort them
# pagination
use the Pageable Object like the sort object in the queries
```java
public interface PersonRepository extends JpaRepository<Courses, Long> {
    Page<Person> findByName(String name,Pageable pageable);
}

Pageable pageable = PageRequest.of(0,5,Sort.by("name").desceding());
Page<Person> personPage = personRepository.findByName("chaitanya", pageable);
```

where 0 is the start index of the first page and 5 is the number of records per page
the personPage will have at max 5 entries and meta data about the page, like total number of records, number of pages, current page number and if next page is available   
we can expect the start and the field that is name from the @RequestParams anbd show content dynamically




# composite primary keys and embedded fields
achieved via Embedded entities
create a class OrderId.java and the columns in it will server as the primary key
```java
@Data
@AllArgsContructor
@NoArgsConstructor
@Embeddable
public class OrderId implements Serializable {
	private String username;
	private LocalDateTime orderDate;
}

@Data
@AllArgsContructor
@NoArgsConstructor
@Entity
public class Order {
	@EmbeddedId
	private OrderId id;
	private String orderInfo;
	@Embedded
	private OtherProperties;
}

@Embeddable
public class OtherProperties{

}
```
