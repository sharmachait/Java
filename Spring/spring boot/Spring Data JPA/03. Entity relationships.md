# unidirectional one to one
1. create a field of the Model we want the relationship with
```java
@data
@Entity
public class Person {

	@OneToOne(fetch = FetchType.EAGER, cascade=CascadeType.ALL, targetEntity = Address.class)
	@JoinColumn(name = "address_id", referencedColumnName = "addressId", nullable = true)
	private Address address;
}
```
in the joincolumn annotation 
the name is the name of the column in the Person table in the database and the 
referencedColumnName is the name of the field in the target Entity Class
the targetEntity is an optional as we have already defined the target entity in the field data type
###### FetchType defines that whenever the Person is fetched from the database then the Address will be fetched along with it

###### FetchType Eager is default for OneToOne and ManyToOne

the other possible type is LAZY, it will only fetch data from database when we do person.getAddress()

by default \*ToMany are lazy - because too many to fetch the query will be slowed
and all \*ToOne are eager

## Cascade types
we have 6 cascade types they allow us to configure how the change to the parent table should propagate down to child table
- PERSIST - save() persists down to child, if we update an entity with save() the child entity wont be updated automatically, persist only cascades the insert operation
- MERGE - when two parents are merged merge the children as well, updates, not handled by PERSIST are handled by MERGE
```java
@OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
@JoinColumn(name = "address_id", referencedColumnName = "id")
private UserAddress userAddress;
```
- REMOVE - dont use in scenario like User - Role because when we delete the user role will also be deleted
- ALL 
- DETACH - when a parent is detached from the db context detach the child as well
- REFRESH - child also gets reloaded from database when parent is reloaded, by passing the level 1 cache
## but how to add foreign key over a composite embedded id

use @JoinColumns and give the fields of the embeddedId into the join columns

```java
@Entity
public class UserAddress{
	@EmbeddedId
	private UserAddressCK id;
}

@Embeddable
public class UserAddressCK {
	private String street;
	private String pinCode;
}

@Entity
public class UserDetails {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	
	@OneToOne(cascade = CascadeType.ALL)
	@JoinColumns({
		@JoinColumn(name="address_street", referencedColumnName = "street"),
		@JoinColumn(name="address_pin_code", referencedColumnName = "pinCode")
	})
	private UserAddress userAddress;
}
```
#### to omit a field from json serialization and desirailization
use @JsonIgnore on top of that field
```java
@Data  
@Entity  
public class Category {  
  @Id  
  @GeneratedValue(strategy = GenerationType.IDENTITY)  
  private Long id;  
  private String name;  
  
  @OneToMany(mappedBy = "category")  
  @JsonIgnore  
  private List<Product> products;  
}
```

# Bidirectional one to one
```java
public class SchoolClass {
	@OneToOne(mappedBy = "schoolClass")
	@JsonBackReference
	private Teacher teacher;
}
public class Teacher {
	@OneToOne(cascade = CascadeType.ALL)
	@JoinColumn(name="school_id", referencedColumnName="id", nullable=false,unique=true,updatable=false)
	@JsonManagedReference
	private SchoolClass schoolClass;
}
```
# Bidirectional Many to One
The table that is on the one side that own the join column in the database is the owner of the relationship
```java
@Entity
public class Person extends BaseEntity{
	@ManyToOne(fetch = FetchType.LAZY, optional = true)
	@JoinColumn(name = "class_id", referencedColumnName = "classId", nullable = true)
	private SchoolClass className;
}

@Entity
public class SchoolClass extends BaseEntity{
	@OneToMany(mappedBy = "className", 
		fetch = FetchType.LAZY, 
		cascade = CascadeType.PERSIST, 
		targetEntity = Person.class,
		orphanRemoval = true)
	private Set<Person> students;
}
```

mappedBy is the name of the field in the other class

# Many to many
```java
@Entity
public class Person extends BaseEntity{
	@Id
	Long personId;
	
	@ManyToMany(fetch = FetchType.EAGER, Cascade = CascadeType=PERSIST)
	@JoinTable(name = "person_courses",
		joinColumns = {@JoinColumn(name = "person_id", referencedColumnName="personId")},
		inverseJoinColumns = {@JoinColumn(name = "course_id", referencedColumnName="courseId")},
	)
	private Set<Course> courses = new HashSet<>();
}

@Entity
public class Course extends BaseEntity{
	@Id
	Long courseId;
	
	@ManyToMany(mappedBy = "courses", 
		fetch = FetchType.EAGER, 
		cascade = CascadeType.PERSIST)
	private Set<Person> students = new HashSet<>();
}
```