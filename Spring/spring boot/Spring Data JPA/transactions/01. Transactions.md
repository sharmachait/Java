1. A @transactional method call must always be made a another bean
2. @Transactional transactions work on AOP, if the method call does not originate in another bean it doesnt cross the proxy object boundary, and transaction doesnt work
```java
@Service
public SomeService {
	
	public void barter(Money amount, Account from, Account to){
		transfer();
	}
	
	@Transactional
	public void transfer(Money amount, Account from, Account to){
	
	}
}
```

the above example doesnt work

we need to call the transfer method from another bean or it to work
# and since @transactional works on AOP the method needs to be public?

# if @transactional is applied at the class level only the public methods are actually transactional


by default spring data JPA does implicit transactions for all the repository methods
there are two types of implicit transactions
- Read operations are done in a read only context
- Updates and deletes are done with default transaction context
in case of @DataJpaTest spring data jpa implicit transactions are not used because tests create explicit transactions, and if explicit transactions are created implicit ones are not used

When you see an error like `LazyInitializationException: could not initialize proxy - no Session` or `failed to lazily initialize a collection of role: ... - no session or session was closed`, it means:

1. You retrieved an entity from the database using Hibernate/JPA
2. The transaction or persistence context that loaded the entity has closed
3. You're now trying to access a lazy-loaded property (like a collection or related entity) that wasn't loaded during the initial query
4. Since the session is closed, Hibernate can't go back to the database to fetch the missing data

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Transactional(readOnly = true)
    public User getUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}

@RestController
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping("/users/{id}")
    public List<Order> getUserOrders(@PathVariable Long id) {
        User user = userService.getUser(id);
        // ERROR happens here - user.getOrders() is lazy-loaded
        return user.getOrders(); 
    }
}
```
with readOnly = true we optimize for read operations
jpa derived queries use readOnly=true transactions can be overridden like so
```java
@Override
@Transactional(readOnly=true)
Optional<User> findById(Long id); 
```
Transactional methods can not be private, because spring data jpa uses AOP to wrap them in transactions

only one transaction is created in the below example unless we use REQUIRES_NEW propagation, in that case there will be 2
```java
@Transactional
public void parentmethod(){
	a();
	b();
}
@Transactional
public void a(){
}
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void b(){
}
```
###### readonly Performance Benefits
1. **Query Caching**: Hibernate can better cache read-only transactions since it knows the data won't change
2. **No Dirty Checking**: Hibernate skips the dirty checking process (which looks for changes in entities to generate update statements)
3. **No Flush**: The persistence context won't be flushed automatically since no changes are expected
other properties are 
- Propagation
	- REQUIRED - use existing transaction or create new
	- SUPPORTS - use if existing, or execute non transactionally
	- MANDATORY - use mandatorily current, else throw exception
	- REQUIRES_NEW - create new
	- NOT_SUPPORTED - execute without transaction, suspend the current one is exists
	- NEVER - OUTSIDE TRNSACTION THROW EXCEPTION IF EXISTS
	- NESTED - create transaction inside transaction 
- Isolation
- timeout
- rollbackFor - Exception classes for which we should rollback
- NoRollebackFor - Exception classes for which we should not rollback
